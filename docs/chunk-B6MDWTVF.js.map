{"version":3,"sources":["node_modules/@babylonjs/core/Lights/lightConstants.js","node_modules/@babylonjs/core/Materials/clipPlaneMaterialHelper.js","node_modules/@babylonjs/core/Materials/materialHelper.functions.js","node_modules/@babylonjs/core/Maths/math.functions.js","node_modules/@babylonjs/core/Shaders/gpuTransform.vertex.js","node_modules/@babylonjs/core/Shaders/gpuTransform.fragment.js","node_modules/@babylonjs/core/Culling/Helper/transformFeedbackBoundingHelper.js"],"sourcesContent":["/** Defines the cross module constantsused by lights to avoid circular dependencies */\nexport class LightConstants {\n  /**\n   * Sort function to order lights for rendering.\n   * @param a First Light object to compare to second.\n   * @param b Second Light object to compare first.\n   * @returns -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.\n   */\n  static CompareLightsPriority(a, b) {\n    //shadow-casting lights have priority over non-shadow-casting lights\n    //the renderPriority is a secondary sort criterion\n    if (a.shadowEnabled !== b.shadowEnabled) {\n      return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);\n    }\n    return b.renderPriority - a.renderPriority;\n  }\n}\n/**\n * Falloff Default: light is falling off following the material specification:\n * standard material is using standard falloff whereas pbr material can request special falloff per materials.\n */\nLightConstants.FALLOFF_DEFAULT = 0;\n/**\n * Falloff Physical: light is falling off following the inverse squared distance law.\n */\nLightConstants.FALLOFF_PHYSICAL = 1;\n/**\n * Falloff gltf: light is falling off as described in the gltf moving to PBR document\n * to enhance interoperability with other engines.\n */\nLightConstants.FALLOFF_GLTF = 2;\n/**\n * Falloff Standard: light is falling off like in the standard material\n * to enhance interoperability with other materials.\n */\nLightConstants.FALLOFF_STANDARD = 3;\n//lightmapMode Consts\n/**\n * If every light affecting the material is in this lightmapMode,\n * material.lightmapTexture adds or multiplies\n * (depends on material.useLightmapAsShadowmap)\n * after every other light calculations.\n */\nLightConstants.LIGHTMAP_DEFAULT = 0;\n/**\n * material.lightmapTexture as only diffuse lighting from this light\n * adds only specular lighting from this light\n * adds dynamic shadows\n */\nLightConstants.LIGHTMAP_SPECULAR = 1;\n/**\n * material.lightmapTexture as only lighting\n * no light calculation from this light\n * only adds dynamic shadows from this light\n */\nLightConstants.LIGHTMAP_SHADOWSONLY = 2;\n// Intensity Mode Consts\n/**\n * Each light type uses the default quantity according to its type:\n *      point/spot lights use luminous intensity\n *      directional lights use illuminance\n */\nLightConstants.INTENSITYMODE_AUTOMATIC = 0;\n/**\n * lumen (lm)\n */\nLightConstants.INTENSITYMODE_LUMINOUSPOWER = 1;\n/**\n * candela (lm/sr)\n */\nLightConstants.INTENSITYMODE_LUMINOUSINTENSITY = 2;\n/**\n * lux (lm/m^2)\n */\nLightConstants.INTENSITYMODE_ILLUMINANCE = 3;\n/**\n * nit (cd/m^2)\n */\nLightConstants.INTENSITYMODE_LUMINANCE = 4;\n// Light types ids const.\n/**\n * Light type const id of the point light.\n */\nLightConstants.LIGHTTYPEID_POINTLIGHT = 0;\n/**\n * Light type const id of the directional light.\n */\nLightConstants.LIGHTTYPEID_DIRECTIONALLIGHT = 1;\n/**\n * Light type const id of the spot light.\n */\nLightConstants.LIGHTTYPEID_SPOTLIGHT = 2;\n/**\n * Light type const id of the hemispheric light.\n */\nLightConstants.LIGHTTYPEID_HEMISPHERICLIGHT = 3;\n","/** @internal */\nexport function addClipPlaneUniforms(uniforms) {\n  if (uniforms.indexOf(\"vClipPlane\") === -1) {\n    uniforms.push(\"vClipPlane\");\n  }\n  if (uniforms.indexOf(\"vClipPlane2\") === -1) {\n    uniforms.push(\"vClipPlane2\");\n  }\n  if (uniforms.indexOf(\"vClipPlane3\") === -1) {\n    uniforms.push(\"vClipPlane3\");\n  }\n  if (uniforms.indexOf(\"vClipPlane4\") === -1) {\n    uniforms.push(\"vClipPlane4\");\n  }\n  if (uniforms.indexOf(\"vClipPlane5\") === -1) {\n    uniforms.push(\"vClipPlane5\");\n  }\n  if (uniforms.indexOf(\"vClipPlane6\") === -1) {\n    uniforms.push(\"vClipPlane6\");\n  }\n}\n/** @internal */\nexport function prepareStringDefinesForClipPlanes(primaryHolder, secondaryHolder, defines) {\n  const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\n  const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\n  const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\n  const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\n  const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\n  const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\n  if (clipPlane) defines.push(\"#define CLIPPLANE\");\n  if (clipPlane2) defines.push(\"#define CLIPPLANE2\");\n  if (clipPlane3) defines.push(\"#define CLIPPLANE3\");\n  if (clipPlane4) defines.push(\"#define CLIPPLANE4\");\n  if (clipPlane5) defines.push(\"#define CLIPPLANE5\");\n  if (clipPlane6) defines.push(\"#define CLIPPLANE6\");\n}\n/** @internal */\nexport function prepareDefinesForClipPlanes(primaryHolder, secondaryHolder, defines) {\n  let changed = false;\n  const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\n  const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\n  const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\n  const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\n  const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\n  const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\n  // Do not factorize this code, it breaks browsers optimizations.\n  if (defines[\"CLIPPLANE\"] !== clipPlane) {\n    defines[\"CLIPPLANE\"] = clipPlane;\n    changed = true;\n  }\n  if (defines[\"CLIPPLANE2\"] !== clipPlane2) {\n    defines[\"CLIPPLANE2\"] = clipPlane2;\n    changed = true;\n  }\n  if (defines[\"CLIPPLANE3\"] !== clipPlane3) {\n    defines[\"CLIPPLANE3\"] = clipPlane3;\n    changed = true;\n  }\n  if (defines[\"CLIPPLANE4\"] !== clipPlane4) {\n    defines[\"CLIPPLANE4\"] = clipPlane4;\n    changed = true;\n  }\n  if (defines[\"CLIPPLANE5\"] !== clipPlane5) {\n    defines[\"CLIPPLANE5\"] = clipPlane5;\n    changed = true;\n  }\n  if (defines[\"CLIPPLANE6\"] !== clipPlane6) {\n    defines[\"CLIPPLANE6\"] = clipPlane6;\n    changed = true;\n  }\n  return changed;\n}\n/** @internal */\nexport function bindClipPlane(effect, primaryHolder, secondaryHolder) {\n  let clipPlane = primaryHolder.clipPlane ?? secondaryHolder.clipPlane;\n  setClipPlane(effect, \"vClipPlane\", clipPlane);\n  clipPlane = primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2;\n  setClipPlane(effect, \"vClipPlane2\", clipPlane);\n  clipPlane = primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3;\n  setClipPlane(effect, \"vClipPlane3\", clipPlane);\n  clipPlane = primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4;\n  setClipPlane(effect, \"vClipPlane4\", clipPlane);\n  clipPlane = primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5;\n  setClipPlane(effect, \"vClipPlane5\", clipPlane);\n  clipPlane = primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6;\n  setClipPlane(effect, \"vClipPlane6\", clipPlane);\n}\nfunction setClipPlane(effect, uniformName, clipPlane) {\n  if (clipPlane) {\n    effect.setFloat4(uniformName, clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\n  }\n}\n","import { Logger } from \"../Misc/logger.js\";\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { LightConstants } from \"../Lights/lightConstants.js\";\nimport { prepareDefinesForClipPlanes } from \"./clipPlaneMaterialHelper.js\";\n// Temps\nconst _TempFogColor = Color3.Black();\nconst _TmpMorphInfluencers = {\n  NUM_MORPH_INFLUENCERS: 0\n};\n/**\n * Binds the logarithmic depth information from the scene to the effect for the given defines.\n * @param defines The generated defines used in the effect\n * @param effect The effect we are binding the data to\n * @param scene The scene we are willing to render with logarithmic scale for\n */\nexport function BindLogDepth(defines, effect, scene) {\n  if (!defines || defines[\"LOGARITHMICDEPTH\"] || defines.indexOf && defines.indexOf(\"LOGARITHMICDEPTH\") >= 0) {\n    const camera = scene.activeCamera;\n    if (camera.mode === 1) {\n      Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\n    }\n    effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\n  }\n}\n/**\n * Binds the fog information from the scene to the effect for the given mesh.\n * @param scene The scene the lights belongs to\n * @param mesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n * @param linearSpace Defines if the fog effect is applied in linear space\n */\nexport function BindFogParameters(scene, mesh, effect, linearSpace = false) {\n  if (effect && scene.fogEnabled && (!mesh || mesh.applyFog) && scene.fogMode !== 0) {\n    effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n    // Convert fog color to linear space if used in a linear space computed shader.\n    if (linearSpace) {\n      scene.fogColor.toLinearSpaceToRef(_TempFogColor, scene.getEngine().useExactSrgbConversions);\n      effect.setColor3(\"vFogColor\", _TempFogColor);\n    } else {\n      effect.setColor3(\"vFogColor\", scene.fogColor);\n    }\n  }\n}\n/**\n * Prepares the list of attributes required for morph targets according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare the morph targets attributes for\n * @param influencers The number of influencers\n */\nexport function PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, influencers) {\n  _TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\n  PrepareAttributesForMorphTargets(attribs, mesh, _TmpMorphInfluencers);\n}\n/**\n * Prepares the list of attributes required for morph targets according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare the morph targets attributes for\n * @param defines The current Defines of the effect\n */\nexport function PrepareAttributesForMorphTargets(attribs, mesh, defines) {\n  const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\n  if (influencers > 0 && EngineStore.LastCreatedEngine) {\n    const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\n    const manager = mesh.morphTargetManager;\n    if (manager?.isUsingTextureForTargets) {\n      return;\n    }\n    const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\n    const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\n    const uv = manager && manager.supportsUVs && defines[\"UV1\"];\n    for (let index = 0; index < influencers; index++) {\n      attribs.push(`position` + index);\n      if (normal) {\n        attribs.push(`normal` + index);\n      }\n      if (tangent) {\n        attribs.push(`tangent` + index);\n      }\n      if (uv) {\n        attribs.push(`uv` + \"_\" + index);\n      }\n      if (attribs.length > maxAttributesCount) {\n        Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\n      }\n    }\n  }\n}\n/**\n * Add the list of attributes required for instances to the attribs array.\n * @param attribs The current list of supported attribs\n * @param needsPreviousMatrices If the shader needs previous matrices\n */\nexport function PushAttributesForInstances(attribs, needsPreviousMatrices = false) {\n  attribs.push(\"world0\");\n  attribs.push(\"world1\");\n  attribs.push(\"world2\");\n  attribs.push(\"world3\");\n  if (needsPreviousMatrices) {\n    attribs.push(\"previousWorld0\");\n    attribs.push(\"previousWorld1\");\n    attribs.push(\"previousWorld2\");\n    attribs.push(\"previousWorld3\");\n  }\n}\n/**\n * Binds the morph targets information from the mesh to the effect.\n * @param abstractMesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n */\nexport function BindMorphTargetParameters(abstractMesh, effect) {\n  const manager = abstractMesh.morphTargetManager;\n  if (!abstractMesh || !manager) {\n    return;\n  }\n  effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\n}\n/**\n * Binds the scene's uniform buffer to the effect.\n * @param effect defines the effect to bind to the scene uniform buffer\n * @param sceneUbo defines the uniform buffer storing scene data\n */\nexport function BindSceneUniformBuffer(effect, sceneUbo) {\n  sceneUbo.bindToEffect(effect, \"Scene\");\n}\n/**\n * Helps preparing the defines values about the UVs in used in the effect.\n * UVs are shared as much as we can across channels in the shaders.\n * @param texture The texture we are preparing the UVs for\n * @param defines The defines to update\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n */\nexport function PrepareDefinesForMergedUV(texture, defines, key) {\n  defines._needUVs = true;\n  defines[key] = true;\n  if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {\n    defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\n    defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\n  } else {\n    defines[key + \"DIRECTUV\"] = 0;\n  }\n}\n/**\n * Binds a texture matrix value to its corresponding uniform\n * @param texture The texture to bind the matrix for\n * @param uniformBuffer The uniform buffer receiving the data\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n */\nexport function BindTextureMatrix(texture, uniformBuffer, key) {\n  const matrix = texture.getTextureMatrix();\n  uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\n}\n/**\n * Prepares the list of attributes required for baked vertex animations according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare for baked vertex animations\n * @param defines The current Defines of the effect\n */\nexport function PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines) {\n  const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\n  if (enabled) {\n    attribs.push(\"bakedVertexAnimationSettingsInstanced\");\n  }\n}\n// Copies the bones transformation matrices into the target array and returns the target's reference\nfunction _CopyBonesTransformationMatrices(source, target) {\n  target.set(source);\n  return target;\n}\n/**\n * Binds the bones information from the mesh to the effect.\n * @param mesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\n */\nexport function BindBonesParameters(mesh, effect, prePassConfiguration) {\n  if (!effect || !mesh) {\n    return;\n  }\n  if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\n    mesh.computeBonesUsingShaders = false;\n  }\n  if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n    const skeleton = mesh.skeleton;\n    if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\n      const boneTexture = skeleton.getTransformMatrixTexture(mesh);\n      effect.setTexture(\"boneSampler\", boneTexture);\n      effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n    } else {\n      const matrices = skeleton.getTransformMatrices(mesh);\n      if (matrices) {\n        effect.setMatrices(\"mBones\", matrices);\n        if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {\n          if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\n            prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\n          }\n          effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\n          _CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\n        }\n      }\n    }\n  }\n}\n/**\n * Binds the light information to the effect.\n * @param light The light containing the generator\n * @param effect The effect we are binding the data to\n * @param lightIndex The light index in the effect used to render\n */\nexport function BindLightProperties(light, effect, lightIndex) {\n  light.transferToEffect(effect, lightIndex + \"\");\n}\n/**\n * Binds the lights information from the scene to the effect for the given mesh.\n * @param light Light to bind\n * @param lightIndex Light index\n * @param scene The scene where the light belongs to\n * @param effect The effect we are binding the data to\n * @param useSpecular Defines if specular is supported\n * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n */\nexport function BindLight(light, lightIndex, scene, effect, useSpecular, receiveShadows = true) {\n  light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\n}\n/**\n * Binds the lights information from the scene to the effect for the given mesh.\n * @param scene The scene the lights belongs to\n * @param mesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n * @param defines The generated defines for the effect\n * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\n */\nexport function BindLights(scene, mesh, effect, defines, maxSimultaneousLights = 4) {\n  const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\n  for (let i = 0; i < len; i++) {\n    const light = mesh.lightSources[i];\n    BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\n  }\n}\n/**\n * Prepares the list of attributes required for bones according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare the bones attributes for\n * @param defines The current Defines of the effect\n * @param fallbacks The current effect fallback strategy\n */\nexport function PrepareAttributesForBones(attribs, mesh, defines, fallbacks) {\n  if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\n    fallbacks.addCPUSkinningFallback(0, mesh);\n    attribs.push(`matricesIndices`);\n    attribs.push(`matricesWeights`);\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\n      attribs.push(`matricesIndicesExtra`);\n      attribs.push(`matricesWeightsExtra`);\n    }\n  }\n}\n/**\n * Check and prepare the list of attributes required for instances according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param defines The current MaterialDefines of the effect\n */\nexport function PrepareAttributesForInstances(attribs, defines) {\n  if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\n    PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\n  }\n  if (defines.INSTANCESCOLOR) {\n    attribs.push(`instanceColor`);\n  }\n}\n/**\n * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\n * @param defines The defines to update while falling back\n * @param fallbacks The authorized effect fallbacks\n * @param maxSimultaneousLights The maximum number of lights allowed\n * @param rank the current rank of the Effect\n * @returns The newly affected rank\n */\nexport function HandleFallbacksForShadows(defines, fallbacks, maxSimultaneousLights = 4, rank = 0) {\n  let lightFallbackRank = 0;\n  for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n    if (!defines[\"LIGHT\" + lightIndex]) {\n      break;\n    }\n    if (lightIndex > 0) {\n      lightFallbackRank = rank + lightIndex;\n      fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\n    }\n    if (!defines[\"SHADOWS\"]) {\n      if (defines[\"SHADOW\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\n      }\n      if (defines[\"SHADOWPCF\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\n      }\n      if (defines[\"SHADOWPCSS\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\n      }\n      if (defines[\"SHADOWPOISSON\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\n      }\n      if (defines[\"SHADOWESM\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\n      }\n      if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\n        fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\n      }\n    }\n  }\n  return lightFallbackRank++;\n}\n/**\n * Gets the current status of the fog (should it be enabled?)\n * @param mesh defines the mesh to evaluate for fog support\n * @param scene defines the hosting scene\n * @returns true if fog must be enabled\n */\nexport function GetFogState(mesh, scene) {\n  return scene.fogEnabled && mesh.applyFog && scene.fogMode !== 0;\n}\n/**\n * Helper used to prepare the list of defines associated with misc. values for shader compilation\n * @param mesh defines the current mesh\n * @param scene defines the current scene\n * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\n * @param pointsCloud defines if point cloud rendering has to be turned on\n * @param fogEnabled defines if fog has to be turned on\n * @param alphaTest defines if alpha testing has to be turned on\n * @param defines defines the current list of defines\n * @param applyDecalAfterDetail Defines if the decal is applied after or before the detail\n */\nexport function PrepareDefinesForMisc(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines, applyDecalAfterDetail = false) {\n  if (defines._areMiscDirty) {\n    defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\n    defines[\"POINTSIZE\"] = pointsCloud;\n    defines[\"FOG\"] = fogEnabled && GetFogState(mesh, scene);\n    defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\n    defines[\"ALPHATEST\"] = alphaTest;\n    defines[\"DECAL_AFTER_DETAIL\"] = applyDecalAfterDetail;\n  }\n}\n/**\n * Prepares the defines related to the light information passed in parameter\n * @param scene The scene we are intending to draw\n * @param mesh The mesh the effect is compiling for\n * @param defines The defines to update\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\n * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\n * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\n * @returns true if normals will be required for the rest of the effect\n */\nexport function PrepareDefinesForLights(scene, mesh, defines, specularSupported, maxSimultaneousLights = 4, disableLighting = false) {\n  if (!defines._areLightsDirty) {\n    return defines._needNormals;\n  }\n  let lightIndex = 0;\n  const state = {\n    needNormals: defines._needNormals,\n    needRebuild: false,\n    lightmapMode: false,\n    shadowEnabled: false,\n    specularEnabled: false\n  };\n  if (scene.lightsEnabled && !disableLighting) {\n    for (const light of mesh.lightSources) {\n      PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\n      lightIndex++;\n      if (lightIndex === maxSimultaneousLights) {\n        break;\n      }\n    }\n  }\n  defines[\"SPECULARTERM\"] = state.specularEnabled;\n  defines[\"SHADOWS\"] = state.shadowEnabled;\n  // Resetting all other lights if any\n  for (let index = lightIndex; index < maxSimultaneousLights; index++) {\n    if (defines[\"LIGHT\" + index] !== undefined) {\n      defines[\"LIGHT\" + index] = false;\n      defines[\"HEMILIGHT\" + index] = false;\n      defines[\"POINTLIGHT\" + index] = false;\n      defines[\"DIRLIGHT\" + index] = false;\n      defines[\"SPOTLIGHT\" + index] = false;\n      defines[\"SHADOW\" + index] = false;\n      defines[\"SHADOWCSM\" + index] = false;\n      defines[\"SHADOWCSMDEBUG\" + index] = false;\n      defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\n      defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\n      defines[\"SHADOWCSMNOBLEND\" + index] = false;\n      defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\n      defines[\"SHADOWPCF\" + index] = false;\n      defines[\"SHADOWPCSS\" + index] = false;\n      defines[\"SHADOWPOISSON\" + index] = false;\n      defines[\"SHADOWESM\" + index] = false;\n      defines[\"SHADOWCLOSEESM\" + index] = false;\n      defines[\"SHADOWCUBE\" + index] = false;\n      defines[\"SHADOWLOWQUALITY\" + index] = false;\n      defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\n    }\n  }\n  const caps = scene.getEngine().getCaps();\n  if (defines[\"SHADOWFLOAT\"] === undefined) {\n    state.needRebuild = true;\n  }\n  defines[\"SHADOWFLOAT\"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);\n  defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\n  if (state.needRebuild) {\n    defines.rebuild();\n  }\n  return state.needNormals;\n}\n/**\n * Prepares the defines related to the light information passed in parameter\n * @param scene The scene we are intending to draw\n * @param mesh The mesh the effect is compiling for\n * @param light The light the effect is compiling for\n * @param lightIndex The index of the light\n * @param defines The defines to update\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\n * @param state Defines the current state regarding what is needed (normals, etc...)\n * @param state.needNormals\n * @param state.needRebuild\n * @param state.shadowEnabled\n * @param state.specularEnabled\n * @param state.lightmapMode\n */\nexport function PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state) {\n  state.needNormals = true;\n  if (defines[\"LIGHT\" + lightIndex] === undefined) {\n    state.needRebuild = true;\n  }\n  defines[\"LIGHT\" + lightIndex] = true;\n  defines[\"SPOTLIGHT\" + lightIndex] = false;\n  defines[\"HEMILIGHT\" + lightIndex] = false;\n  defines[\"POINTLIGHT\" + lightIndex] = false;\n  defines[\"DIRLIGHT\" + lightIndex] = false;\n  light.prepareLightSpecificDefines(defines, lightIndex);\n  // FallOff.\n  defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\n  defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\n  defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\n  switch (light.falloffType) {\n    case LightConstants.FALLOFF_GLTF:\n      defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\n      break;\n    case LightConstants.FALLOFF_PHYSICAL:\n      defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\n      break;\n    case LightConstants.FALLOFF_STANDARD:\n      defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\n      break;\n  }\n  // Specular\n  if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\n    state.specularEnabled = true;\n  }\n  // Shadows\n  defines[\"SHADOW\" + lightIndex] = false;\n  defines[\"SHADOWCSM\" + lightIndex] = false;\n  defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\n  defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\n  defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\n  defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\n  defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\n  defines[\"SHADOWPCF\" + lightIndex] = false;\n  defines[\"SHADOWPCSS\" + lightIndex] = false;\n  defines[\"SHADOWPOISSON\" + lightIndex] = false;\n  defines[\"SHADOWESM\" + lightIndex] = false;\n  defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\n  defines[\"SHADOWCUBE\" + lightIndex] = false;\n  defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\n  defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\n  if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\n    const shadowGenerator = light.getShadowGenerator(scene.activeCamera) ?? light.getShadowGenerator();\n    if (shadowGenerator) {\n      const shadowMap = shadowGenerator.getShadowMap();\n      if (shadowMap) {\n        if (shadowMap.renderList && shadowMap.renderList.length > 0) {\n          state.shadowEnabled = true;\n          shadowGenerator.prepareDefines(defines, lightIndex);\n        }\n      }\n    }\n  }\n  if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {\n    state.lightmapMode = true;\n    defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\n    defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;\n  } else {\n    defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\n    defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\n  }\n}\n/**\n * Helper used to prepare the list of defines associated with frame values for shader compilation\n * @param scene defines the current scene\n * @param engine defines the current engine\n * @param material defines the material we are compiling the shader for\n * @param defines specifies the list of active defines\n * @param useInstances defines if instances have to be turned on\n * @param useClipPlane defines if clip plane have to be turned on\n * @param useThinInstances defines if thin instances have to be turned on\n */\nexport function PrepareDefinesForFrameBoundValues(scene, engine, material, defines, useInstances, useClipPlane = null, useThinInstances = false) {\n  let changed = PrepareDefinesForCamera(scene, defines);\n  if (useClipPlane !== false) {\n    changed = prepareDefinesForClipPlanes(material, scene, defines);\n  }\n  if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\n    defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\n    changed = true;\n  }\n  if (defines[\"INSTANCES\"] !== useInstances) {\n    defines[\"INSTANCES\"] = useInstances;\n    changed = true;\n  }\n  if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\n    defines[\"THIN_INSTANCES\"] = useThinInstances;\n    changed = true;\n  }\n  if (changed) {\n    defines.markAsUnprocessed();\n  }\n}\n/**\n * Prepares the defines for bones\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForBones(mesh, defines) {\n  if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n    defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\n    const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\n    if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\n      defines[\"BONETEXTURE\"] = true;\n    } else {\n      defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\n      defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\n      const prePassRenderer = mesh.getScene().prePassRenderer;\n      if (prePassRenderer && prePassRenderer.enabled) {\n        const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\n        defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\n      }\n    }\n  } else {\n    defines[\"NUM_BONE_INFLUENCERS\"] = 0;\n    defines[\"BonesPerMesh\"] = 0;\n    if (defines[\"BONETEXTURE\"] !== undefined) {\n      defines[\"BONETEXTURE\"] = false;\n    }\n  }\n}\n/**\n * Prepares the defines for morph targets\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForMorphTargets(mesh, defines) {\n  const manager = mesh.morphTargetManager;\n  if (manager) {\n    defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\n    defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\n    defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\n    defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numMaxInfluencers || manager.numInfluencers;\n    defines[\"MORPHTARGETS\"] = defines[\"NUM_MORPH_INFLUENCERS\"] > 0;\n    defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\n  } else {\n    defines[\"MORPHTARGETS_UV\"] = false;\n    defines[\"MORPHTARGETS_TANGENT\"] = false;\n    defines[\"MORPHTARGETS_NORMAL\"] = false;\n    defines[\"MORPHTARGETS\"] = false;\n    defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\n  }\n}\n/**\n * Prepares the defines for baked vertex animation\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForBakedVertexAnimation(mesh, defines) {\n  const manager = mesh.bakedVertexAnimationManager;\n  defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\n}\n/**\n * Prepares the defines used in the shader depending on the attributes data available in the mesh\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\n * @param useBones Precise whether bones should be used or not (override mesh info)\n * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\n * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\n * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\n * @returns false if defines are considered not dirty and have not been checked\n */\nexport function PrepareDefinesForAttributes(mesh, defines, useVertexColor, useBones, useMorphTargets = false, useVertexAlpha = true, useBakedVertexAnimation = true) {\n  if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\n    return false;\n  }\n  defines._normals = defines._needNormals;\n  defines._uvs = defines._needUVs;\n  defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(`normal`);\n  if (defines._needNormals && mesh.isVerticesDataPresent(`tangent`)) {\n    defines[\"TANGENT\"] = true;\n  }\n  for (let i = 1; i <= 6; ++i) {\n    defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\n  }\n  if (useVertexColor) {\n    const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(`color`);\n    defines[\"VERTEXCOLOR\"] = hasVertexColors;\n    defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\n  }\n  if (mesh.isVerticesDataPresent(`instanceColor`) && (mesh.hasInstances || mesh.hasThinInstances)) {\n    defines[\"INSTANCESCOLOR\"] = true;\n  }\n  if (useBones) {\n    PrepareDefinesForBones(mesh, defines);\n  }\n  if (useMorphTargets) {\n    PrepareDefinesForMorphTargets(mesh, defines);\n  }\n  if (useBakedVertexAnimation) {\n    PrepareDefinesForBakedVertexAnimation(mesh, defines);\n  }\n  return true;\n}\n/**\n * Prepares the defines related to multiview\n * @param scene The scene we are intending to draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForMultiview(scene, defines) {\n  if (scene.activeCamera) {\n    const previousMultiview = defines.MULTIVIEW;\n    defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\n    if (defines.MULTIVIEW != previousMultiview) {\n      defines.markAsUnprocessed();\n    }\n  }\n}\n/**\n * Prepares the defines related to order independant transparency\n * @param scene The scene we are intending to draw\n * @param defines The defines to update\n * @param needAlphaBlending Determines if the material needs alpha blending\n */\nexport function PrepareDefinesForOIT(scene, defines, needAlphaBlending) {\n  const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\n  const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\n  defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\n  defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\n  if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\n    defines.markAsUnprocessed();\n  }\n}\n/**\n * Prepares the defines related to the prepass\n * @param scene The scene we are intending to draw\n * @param defines The defines to update\n * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\n */\nexport function PrepareDefinesForPrePass(scene, defines, canRenderToMRT) {\n  const previousPrePass = defines.PREPASS;\n  if (!defines._arePrePassDirty) {\n    return;\n  }\n  const texturesList = [{\n    type: 1,\n    define: \"PREPASS_POSITION\",\n    index: \"PREPASS_POSITION_INDEX\"\n  }, {\n    type: 2,\n    define: \"PREPASS_VELOCITY\",\n    index: \"PREPASS_VELOCITY_INDEX\"\n  }, {\n    type: 3,\n    define: \"PREPASS_REFLECTIVITY\",\n    index: \"PREPASS_REFLECTIVITY_INDEX\"\n  }, {\n    type: 0,\n    define: \"PREPASS_IRRADIANCE\",\n    index: \"PREPASS_IRRADIANCE_INDEX\"\n  }, {\n    type: 7,\n    define: \"PREPASS_ALBEDO_SQRT\",\n    index: \"PREPASS_ALBEDO_SQRT_INDEX\"\n  }, {\n    type: 5,\n    define: \"PREPASS_DEPTH\",\n    index: \"PREPASS_DEPTH_INDEX\"\n  }, {\n    type: 6,\n    define: \"PREPASS_NORMAL\",\n    index: \"PREPASS_NORMAL_INDEX\"\n  }];\n  if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\n    defines.PREPASS = true;\n    defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\n    defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;\n    for (let i = 0; i < texturesList.length; i++) {\n      const index = scene.prePassRenderer.getIndex(texturesList[i].type);\n      if (index !== -1) {\n        defines[texturesList[i].define] = true;\n        defines[texturesList[i].index] = index;\n      } else {\n        defines[texturesList[i].define] = false;\n      }\n    }\n  } else {\n    defines.PREPASS = false;\n    for (let i = 0; i < texturesList.length; i++) {\n      defines[texturesList[i].define] = false;\n    }\n  }\n  if (defines.PREPASS != previousPrePass) {\n    defines.markAsUnprocessed();\n    defines.markAsImageProcessingDirty();\n  }\n}\n/**\n * Helper used to prepare the defines relative to the active camera\n * @param scene defines the current scene\n * @param defines specifies the list of active defines\n * @returns true if the defines have been updated, else false\n */\nexport function PrepareDefinesForCamera(scene, defines) {\n  let changed = false;\n  if (scene.activeCamera) {\n    const wasOrtho = defines[\"CAMERA_ORTHOGRAPHIC\"] ? 1 : 0;\n    const wasPersp = defines[\"CAMERA_PERSPECTIVE\"] ? 1 : 0;\n    const isOrtho = scene.activeCamera.mode === 1 ? 1 : 0;\n    const isPersp = scene.activeCamera.mode === 0 ? 1 : 0;\n    if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {\n      defines[\"CAMERA_ORTHOGRAPHIC\"] = isOrtho === 1;\n      defines[\"CAMERA_PERSPECTIVE\"] = isPersp === 1;\n      changed = true;\n    }\n  }\n  return changed;\n}\n/**\n * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\n * @param lightIndex defines the light index\n * @param uniformsList The uniform list\n * @param samplersList The sampler list\n * @param projectedLightTexture defines if projected texture must be used\n * @param uniformBuffersList defines an optional list of uniform buffers\n * @param updateOnlyBuffersList True to only update the uniformBuffersList array\n */\nexport function PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList = null, updateOnlyBuffersList = false) {\n  if (uniformBuffersList) {\n    uniformBuffersList.push(\"Light\" + lightIndex);\n  }\n  if (updateOnlyBuffersList) {\n    return;\n  }\n  uniformsList.push(\"vLightData\" + lightIndex, \"vLightDiffuse\" + lightIndex, \"vLightSpecular\" + lightIndex, \"vLightDirection\" + lightIndex, \"vLightFalloff\" + lightIndex, \"vLightGround\" + lightIndex, \"lightMatrix\" + lightIndex, \"shadowsInfo\" + lightIndex, \"depthValues\" + lightIndex);\n  samplersList.push(\"shadowTexture\" + lightIndex);\n  samplersList.push(\"depthTexture\" + lightIndex);\n  uniformsList.push(\"viewFrustumZ\" + lightIndex, \"cascadeBlendFactor\" + lightIndex, \"lightSizeUVCorrection\" + lightIndex, \"depthCorrection\" + lightIndex, \"penumbraDarkness\" + lightIndex, \"frustumLengths\" + lightIndex);\n  if (projectedLightTexture) {\n    samplersList.push(\"projectionLightTexture\" + lightIndex);\n    uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\n  }\n}\n/**\n * Prepares the uniforms and samplers list to be used in the effect\n * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\n * @param samplersList The sampler list\n * @param defines The defines helping in the list generation\n * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\n */\nexport function PrepareUniformsAndSamplersList(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights = 4) {\n  let uniformsList;\n  let uniformBuffersList = null;\n  if (uniformsListOrOptions.uniformsNames) {\n    const options = uniformsListOrOptions;\n    uniformsList = options.uniformsNames;\n    uniformBuffersList = options.uniformBuffersNames;\n    samplersList = options.samplers;\n    defines = options.defines;\n    maxSimultaneousLights = options.maxSimultaneousLights || 0;\n  } else {\n    uniformsList = uniformsListOrOptions;\n    if (!samplersList) {\n      samplersList = [];\n    }\n  }\n  for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n    if (!defines[\"LIGHT\" + lightIndex]) {\n      break;\n    }\n    PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\n  }\n  if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\n    uniformsList.push(\"morphTargetInfluences\");\n    uniformsList.push(\"morphTargetCount\");\n  }\n  if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\n    uniformsList.push(\"bakedVertexAnimationSettings\");\n    uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\n    uniformsList.push(\"bakedVertexAnimationTime\");\n    samplersList.push(\"bakedVertexAnimationTexture\");\n  }\n}\n","import { __decorate } from \"../tslib.es6.js\";\nimport { Vector3 } from \"./math.vector.js\";\nimport { nativeOverride } from \"../Misc/decorators.js\";\n// This helper class is only here so we can apply the nativeOverride decorator to functions.\nclass MathHelpers {\n  static extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum) {\n    for (let index = indexStart; index < indexStart + indexCount; index++) {\n      const offset = indices[index] * 3;\n      const x = positions[offset];\n      const y = positions[offset + 1];\n      const z = positions[offset + 2];\n      minimum.minimizeInPlaceFromFloats(x, y, z);\n      maximum.maximizeInPlaceFromFloats(x, y, z);\n    }\n  }\n  static extractMinAndMax(positions, start, count, stride, minimum, maximum) {\n    for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {\n      const x = positions[offset];\n      const y = positions[offset + 1];\n      const z = positions[offset + 2];\n      minimum.minimizeInPlaceFromFloats(x, y, z);\n      maximum.maximizeInPlaceFromFloats(x, y, z);\n    }\n  }\n}\n__decorate([nativeOverride.filter((...[positions, indices]) => !Array.isArray(positions) && !Array.isArray(indices))\n// eslint-disable-next-line @typescript-eslint/naming-convention\n], MathHelpers, \"extractMinAndMaxIndexed\", null);\n__decorate([nativeOverride.filter((...[positions]) => !Array.isArray(positions))\n// eslint-disable-next-line @typescript-eslint/naming-convention\n], MathHelpers, \"extractMinAndMax\", null);\n/**\n * Extracts minimum and maximum values from a list of indexed positions\n * @param positions defines the positions to use\n * @param indices defines the indices to the positions\n * @param indexStart defines the start index\n * @param indexCount defines the end index\n * @param bias defines bias value to add to the result\n * @returns minimum and maximum values\n */\nexport function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias = null) {\n  const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n  MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);\n  if (bias) {\n    minimum.x -= minimum.x * bias.x + bias.y;\n    minimum.y -= minimum.y * bias.x + bias.y;\n    minimum.z -= minimum.z * bias.x + bias.y;\n    maximum.x += maximum.x * bias.x + bias.y;\n    maximum.y += maximum.y * bias.x + bias.y;\n    maximum.z += maximum.z * bias.x + bias.y;\n  }\n  return {\n    minimum: minimum,\n    maximum: maximum\n  };\n}\n/**\n * Extracts minimum and maximum values from a list of positions\n * @param positions defines the positions to use\n * @param start defines the start index in the positions array\n * @param count defines the number of positions to handle\n * @param bias defines bias value to add to the result\n * @param stride defines the stride size to use (distance between two positions in the positions array)\n * @returns minimum and maximum values\n */\nexport function extractMinAndMax(positions, start, count, bias = null, stride) {\n  const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n  const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n  if (!stride) {\n    stride = 3;\n  }\n  MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);\n  if (bias) {\n    minimum.x -= minimum.x * bias.x + bias.y;\n    minimum.y -= minimum.y * bias.x + bias.y;\n    minimum.z -= minimum.z * bias.x + bias.y;\n    maximum.x += maximum.x * bias.x + bias.y;\n    maximum.y += maximum.y * bias.x + bias.y;\n    maximum.z += maximum.z * bias.x + bias.y;\n  }\n  return {\n    minimum: minimum,\n    maximum: maximum\n  };\n}\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nconst name = \"gpuTransformVertexShader\";\nconst shader = `attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\nout vec3 outPosition;const mat4 identity=mat4(\nvec4(1.0,0.0,0.0,0.0),\nvec4(0.0,1.0,0.0,0.0),\nvec4(0.0,0.0,1.0,0.0),\nvec4(0.0,0.0,0.0,1.0)\n);void main(void) {vec3 positionUpdated=position;\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\nmat4 finalWorld=identity;\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);outPosition=worldPos.xyz;}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gpuTransformVertexShader = {\n  name,\n  shader\n};\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"gpuTransformPixelShader\";\nconst shader = `#version 300 es\nvoid main() {discard;}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gpuTransformPixelShader = {\n  name,\n  shader\n};\n","import { VertexBuffer, Buffer } from \"../../Buffers/buffer.js\";\nimport { BindBonesParameters, BindMorphTargetParameters, PrepareAttributesForBakedVertexAnimation } from \"../../Materials/materialHelper.functions.js\";\nimport { extractMinAndMax } from \"../../Maths/math.functions.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport \"../../Shaders/gpuTransform.vertex.js\";\nimport \"../../Shaders/gpuTransform.fragment.js\";\n/** @internal */\nexport class TransformFeedbackBoundingHelper {\n  /**\n   * Creates a new TransformFeedbackBoundingHelper\n   * @param engine defines the engine to use\n   */\n  constructor(engine) {\n    this._buffers = {};\n    this._effects = {};\n    this._meshListCounter = 0;\n    this._engine = engine;\n  }\n  /** @internal */\n  processAsync(meshes) {\n    if (!Array.isArray(meshes)) {\n      meshes = [meshes];\n    }\n    this._meshListCounter = 0;\n    this._processMeshList(meshes);\n    return Promise.resolve();\n  }\n  _processMeshList(meshes) {\n    const parallelShaderCompile = this._engine.getCaps().parallelShaderCompile;\n    this._engine.getCaps().parallelShaderCompile = undefined;\n    for (let i = 0; i < meshes.length; ++i) {\n      const mesh = meshes[i];\n      const vertexCount = mesh.getTotalVertices();\n      if (vertexCount === 0 || !mesh.getVertexBuffer || !mesh.getVertexBuffer(VertexBuffer.PositionKind)) {\n        continue;\n      }\n      // Get correct effect\n      let computeEffect;\n      let numInfluencers = 0;\n      const defines = [];\n      let uniforms = [];\n      const attribs = [VertexBuffer.PositionKind];\n      const samplers = [];\n      // Bones\n      if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n        attribs.push(VertexBuffer.MatricesIndicesKind);\n        attribs.push(VertexBuffer.MatricesWeightsKind);\n        if (mesh.numBoneInfluencers > 4) {\n          attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n          attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n        }\n        const skeleton = mesh.skeleton;\n        defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n        if (skeleton.isUsingTextureForMatrices) {\n          defines.push(\"#define BONETEXTURE\");\n          if (uniforms.indexOf(\"boneTextureWidth\") === -1) {\n            uniforms.push(\"boneTextureWidth\");\n          }\n          if (samplers.indexOf(\"boneSampler\") === -1) {\n            samplers.push(\"boneSampler\");\n          }\n        } else {\n          defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\n          if (uniforms.indexOf(\"mBones\") === -1) {\n            uniforms.push(\"mBones\");\n          }\n        }\n      } else {\n        defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n      }\n      // Morph\n      const manager = mesh ? mesh.morphTargetManager : null;\n      if (manager) {\n        numInfluencers = manager.numMaxInfluencers || manager.numInfluencers;\n        if (numInfluencers > 0) {\n          defines.push(\"#define MORPHTARGETS\");\n        }\n        if (manager.isUsingTextureForTargets) {\n          defines.push(\"#define MORPHTARGETS_TEXTURE\");\n          if (uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\n            uniforms.push(\"morphTargetTextureIndices\");\n          }\n          if (samplers.indexOf(\"morphTargets\") === -1) {\n            samplers.push(\"morphTargets\");\n          }\n        }\n        defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\n        for (let index = 0; index < numInfluencers; index++) {\n          attribs.push(VertexBuffer.PositionKind + index);\n        }\n        if (numInfluencers > 0) {\n          uniforms = uniforms.slice();\n          uniforms.push(\"morphTargetInfluences\");\n          uniforms.push(\"morphTargetCount\");\n          uniforms.push(\"morphTargetTextureInfo\");\n          uniforms.push(\"morphTargetTextureIndices\");\n        }\n      }\n      // Baked Vertex Animation\n      const bvaManager = mesh.bakedVertexAnimationManager;\n      if (bvaManager && bvaManager.isEnabled) {\n        defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\n        if (uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\n          uniforms.push(\"bakedVertexAnimationSettings\");\n        }\n        if (uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\n          uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\n        }\n        if (uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\n          uniforms.push(\"bakedVertexAnimationTime\");\n        }\n        if (samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\n          samplers.push(\"bakedVertexAnimationTexture\");\n        }\n        PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\n      }\n      const join = defines.join(\"\\n\");\n      if (!this._effects[join]) {\n        const computeEffectOptions = {\n          attributes: attribs,\n          uniformsNames: uniforms,\n          uniformBuffersNames: [],\n          samplers: samplers,\n          defines: join,\n          fallbacks: null,\n          onCompiled: null,\n          onError: null,\n          indexParameters: {\n            maxSimultaneousMorphTargets: numInfluencers\n          },\n          maxSimultaneousLights: 0,\n          transformFeedbackVaryings: [\"outPosition\"]\n        };\n        computeEffect = this._engine.createEffect(\"gpuTransform\", computeEffectOptions, this._engine);\n        this._effects[join] = computeEffect;\n      } else {\n        computeEffect = this._effects[join];\n      }\n      this._compute(mesh, computeEffect);\n    }\n    this._engine.getCaps().parallelShaderCompile = parallelShaderCompile;\n  }\n  _compute(mesh, effect) {\n    const engine = this._engine;\n    // Buffer\n    let targetBuffer;\n    const vertexCount = mesh.getTotalVertices();\n    if (!this._buffers[mesh.uniqueId]) {\n      const targetData = new Float32Array(vertexCount * 3);\n      targetBuffer = new Buffer(mesh.getEngine(), targetData, true, 3);\n      this._buffers[mesh.uniqueId] = targetBuffer;\n    } else {\n      targetBuffer = this._buffers[mesh.uniqueId];\n    }\n    // Bind\n    effect.getEngine().enableEffect(effect);\n    mesh._bindDirect(effect, null, true);\n    // Bones\n    BindBonesParameters(mesh, effect);\n    // Morph targets\n    const manager = mesh.morphTargetManager;\n    if (manager && manager.numInfluencers > 0) {\n      BindMorphTargetParameters(mesh, effect);\n    }\n    // BVA\n    const bvaManager = mesh.bakedVertexAnimationManager;\n    if (bvaManager && bvaManager.isEnabled) {\n      mesh.bakedVertexAnimationManager?.bind(effect, false);\n    }\n    // Update\n    const arrayBuffer = targetBuffer.getData();\n    engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());\n    engine.setRasterizerState(false);\n    engine.beginTransformFeedback(true);\n    engine.drawArraysType(2, 0, vertexCount);\n    engine.endTransformFeedback();\n    engine.setRasterizerState(true);\n    engine.readTransformFeedbackBuffer(arrayBuffer);\n    engine.bindTransformFeedbackBuffer(null);\n    // Update mesh\n    if (this._meshListCounter === 0) {\n      mesh._refreshBoundingInfo(arrayBuffer, null);\n    } else {\n      const bb = mesh.getBoundingInfo().boundingBox;\n      const extend = extractMinAndMax(arrayBuffer, 0, vertexCount);\n      TransformFeedbackBoundingHelper._Min.copyFrom(bb.minimum).minimizeInPlace(extend.minimum);\n      TransformFeedbackBoundingHelper._Max.copyFrom(bb.maximum).maximizeInPlace(extend.maximum);\n      mesh._refreshBoundingInfoDirect({\n        minimum: TransformFeedbackBoundingHelper._Min,\n        maximum: TransformFeedbackBoundingHelper._Max\n      });\n    }\n  }\n  /** @internal */\n  registerMeshListAsync(meshes) {\n    if (!Array.isArray(meshes)) {\n      meshes = [meshes];\n    }\n    this._meshList = meshes;\n    this._meshListCounter = 0;\n    return Promise.resolve();\n  }\n  /** @internal */\n  processMeshList() {\n    if (this._meshList.length === 0) {\n      return;\n    }\n    this._processMeshList(this._meshList);\n    this._meshListCounter++;\n  }\n  /** @internal */\n  fetchResultsForMeshListAsync() {\n    this._meshListCounter = 0;\n    return Promise.resolve();\n  }\n  /** @internal */\n  dispose() {\n    for (const key in this._buffers) {\n      this._buffers[key].dispose();\n    }\n    this._buffers = {};\n    this._effects = {};\n    this._engine = null;\n  }\n}\nTransformFeedbackBoundingHelper._Min = new Vector3();\nTransformFeedbackBoundingHelper._Max = new Vector3();\n"],"mappings":"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","names":["name","shader"],"x_google_ignoreList":[0,1,2,3,4,5,6]}